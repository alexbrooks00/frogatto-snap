{
	instances: [
	{
		//Shadow for drawing an 'iris' transition effect. It looks for
		//Frogatto in the level, finds out where he is in screen space
		//and then blacks out everything except a circle around him.
		//The circle's size is proportional to how far along the
		//transition is.
		name: "iris_transition",
		new: true,
		vertex: """
			uniform mat4 u_anura_mvp_matrix;
			attribute vec2 a_anura_vertex;
			attribute vec2 a_anura_texcoord;
			varying vec2 v_texcoord;
			varying vec2 v_vertex;
			void main()
			{
				v_vertex = a_anura_vertex;
				gl_Position = u_anura_mvp_matrix * vec4(a_anura_vertex, 0.0, 1.0);
				v_texcoord = a_anura_texcoord;
			}
		""",

		fragment: """
           	#version 120
			uniform sampler2D u_anura_tex_map;
			uniform float u_anura_cycle;

			//player's position in screen space.
			uniform vec2 u_player_pos;
			uniform vec4 u_anura_draw_area;

			//value which is 0.0 when the transition has just started
			//and 1.0 when the transition is complete.
			uniform float u_transition_ratio;
			//uniform vec4 u_anura_sprite_area;
			varying vec2 v_texcoord;
			varying vec2 v_vertex;
			void main()
			{
				float dist_x = v_texcoord.x - u_player_pos.x;
				float dist_y = v_texcoord.y - u_player_pos.y;

				float dist = dist_x*dist_x + dist_y*dist_y;

				float max_dist = (1.0 - u_transition_ratio)*(1.0 - u_transition_ratio)*0.7;


				if(dist > max_dist) {
					gl_FragColor = vec4(0.0,0.0,0.0,1.0);
				} else {
					gl_FragColor = texture2D(u_anura_tex_map, v_texcoord);
					if(gl_FragColor.a > 0.02) {
						gl_FragColor.a = 1.0;
					}
				}
			}
		""",

		draw: """[
			set(uniform_commands.u_transition_ratio, level.transition_ratio),
			if(frogatto, [
				set(uniform_commands.u_player_pos, [
					(frogatto.mid_x - level.camera_position[0])/decimal(level.camera_position[2]),
					1.0 - (frogatto.mid_y - level.camera_position[1])/decimal(level.camera_position[3]),
				])
			]),
		] where frogatto = find(level.chars, value is obj frogatto_playable)""",
	},

	{
		name: "liquid",
		new: true,
		vertex: "
			uniform mat4 u_anura_mvp_matrix;
			//uniform float u_anura_cycle;
			//uniform vec4 u_anura_sprite_area;
			//uniform vec4 u_anura_draw_area;
			attribute vec2 a_anura_vertex;
			attribute vec2 a_anura_texcoord;
			varying vec2 v_texcoord;
			varying vec2 v_vertex;
			void main()
			{
				v_vertex = a_anura_vertex;
				gl_Position = u_anura_mvp_matrix * vec4(a_anura_vertex, 0.0, 1.0);
				v_texcoord = a_anura_texcoord;
			}
		",
		fragment: "
			#version 120
			uniform sampler2D u_anura_tex_map;
			uniform sampler2D u_water_texture; //my kingdom for an array
			uniform sampler2D u_acid_texture;
			uniform sampler2D u_deadly_acid_texture;
			uniform sampler2D u_whitewater_texture;
			//[ADDING_WATER] If adding a new water type, add its texture sampler.
			uniform float u_water_tex_dim[4];
			uniform float u_water_tex_speed[4];
			//[ADDING_WATER] If adding a new water type, increase the size of dim and speed by 1 each to accommodate the new data.
			uniform vec4 u_camera_pos;
			uniform float u_zoom;
			//uniform float u_intensity;
			uniform int u_water_count; //Can't be uint, that just... doesn't work. O_o
			uniform vec4 u_water_area[8]; //8 water areas on screen at one time max.
			uniform int u_water_type[8];  //The numeric water types of each area, so we know how to shade them. 1=water, 2=acid, etc.
			uniform float u_anura_cycle;
			uniform vec4 u_anura_draw_area;
			//uniform vec4 u_anura_sprite_area;
			varying vec2 v_texcoord;
			varying vec2 v_vertex;
			


			
			float ease_out_circ(float t)
			{
				return sqrt(1.0 - pow( (t-1.0), 2.0 ) );
			}

			float ease_in_circ(float t)
			{
				return 1.0 - sqrt(1.0 - pow(t, 2.0) );
			}

			float ease_in_out_circ(float t)
			{
				float time = t*2.0;

				if(time < 1.0){ 
					return ( 1.0 - sqrt(1.0 - pow(t,2.0) ) )/2.0;
				} else {
					return sqrt(1.0 - pow( (t-1.0), 2.0 ) )/2.0;
				}
			}

			float blendOverlay(float base, float blend) {
				return base<0.5?(2.0*base*blend):(1.0-2.0*(1.0-base)*(1.0-blend));
			}

			vec3 blendOverlay(vec3 base, vec3 blend) {
				return vec3(blendOverlay(base.r,blend.r),blendOverlay(base.g,blend.g),blendOverlay(base.b,blend.b));
			}

			vec3 blendOverlay(vec3 base, vec3 blend, float opacity) {
				return (blendOverlay(base, blend) * opacity + base * (1.0 - opacity));
			}			


			float blendScreen(float base, float blend) {
				return 1.0-((1.0-base)*(1.0-blend));
			}

			vec3 blendScreen(vec3 base, vec3 blend) {
				return vec3(blendScreen(base.r,blend.r),blendScreen(base.g,blend.g),blendScreen(base.b,blend.b));
			}

			vec3 blendScreen(vec3 base, vec3 blend, float opacity) {
				return (blendScreen(base, blend) * opacity + base * (1.0 - opacity));
			}
		
			void main()
			{
				vec2 texcoord = v_texcoord;
				
				/*
					This steps over multiple water areas - it artificially limits itself to the first 8 water areas that are onscreen (this gets done not here, in the `fragment` call, but down in the `draw` call below).
					
					The final return value is a single pixel's color.
					
					Since of course this is a shader, the end result we're going for is just one single pixel's color, so any 'scanning over multiple pixels' is just to get ingredients, not to output more than one. 
				*/
				
				//Find the index of the water rect whose pixel we're
				//shading. Overlap winning is arbitrary but stable.
				int water_index;
				float left, top, right, bottom;
				for(water_index = 0; water_index < u_water_count; water_index++) {
					left = max(u_anura_draw_area[0], u_water_area[water_index][0]); //Clip the water area to the screen, so that it doesn't slide around near the edge and produce artefacts.
					top = max(u_anura_draw_area[1], u_water_area[water_index][1]);
					right = min(u_anura_draw_area[2], u_water_area[water_index][2]);
					bottom = min(u_anura_draw_area[3], u_water_area[water_index][3]);
					
					//bounds check
					if(
						   v_vertex.x > left 
						&& v_vertex.x < right 
						&& v_vertex.y > top 
						&& v_vertex.y < bottom
					) {
						break; //found water_index, stop looking
					}
				}
				
				//Don't do anything if we didn't find a water.
				if(water_index == u_water_count) {
					gl_FragColor = vec4(texture2D(u_anura_tex_map, texcoord).rgb, 1.0);
					return;
				}
				
				int water_type = u_water_type[water_index];
				
				/*
					This is the heart of our 'distortion'; right now, this works by only 'wobbling' the x-coord of the pixel; basically we decide to sample from a different point in the source texture, based on the current timestamp.
					
					`falloff_ratio` is a 0.0~1.0 float; it attenuates how much horizontal distortion there is.  The idea is that when we get closer to the edge of the water rectangle, we want to reduce the amount of distortion - asymptotically approaching no movement at all when we're flush with the edge of the rectangle.  There are two reasons for this - the first one is that it lines up with how fluid dynamics work IRL - actual liquids in i.e. a Pipe barely move near the edges of it, and have their highest flow out in the middle.   It also, conveniently, completely kills any problems of 'seaming' at the edge of the rectangle.
				*/
				float falloff_ratio = min(min(v_vertex.x - left, right - v_vertex.x)/40.0,1.0);
				
				texcoord.x = texcoord.x + falloff_ratio*sin((u_anura_draw_area[0] + v_vertex.x)*0.02 + u_anura_cycle/20.0)/300.0;
				

				/*
					The following several lines of code basically are figuring out an XY point - their goal is basically let us 'draw the water texture' by essentially deciding where the final pixel is on the screen, and using that to decide where, in the water texture, we should be sampling.  If they're all offset consistently, we'll just be sampling one-by-one and basically 'redrawing' the water texture wherever we want it, pixel by pixel.
				*/
				
				/*
					This adds two XY points together - GLSL has a convenience where adding two points like this automatically adds the components piecewise.
					
					`u_camera_pos` is essentially 'level space integers'; so i.e. 200,250 for x,y if the camera's upper corner is there.
					`u_anura_draw_area` here is an XYWH rect, so this means it's just plucking the width/height values here.
					
					This is extracting a 'fraction' here (normalized 0.0~1.0), of where we're at on the screen.
				*/
				vec2 loc = vec2(u_camera_pos[0]/u_anura_draw_area[2], -u_camera_pos[1]/u_anura_draw_area[3]) + texcoord;

				/*
					Then we take that and divide it against the dimensions of the water texture â€” again, yielding a fraction.  This is meant to tell us where in the water texture we want to sample.  This handles the issue of 'repeating' the texture horizontally and vertically.
				*/
				loc.x *= u_anura_draw_area[2]/u_water_tex_dim[water_type];
				loc.y *= u_anura_draw_area[2]/u_water_tex_dim[water_type];  //Note: This is not a typo, it's not supposed to be u_anura_draw_area[3]. That produces seams.
				
				
				/*
					Finally, we do a little bit of weird mumbo-jumbo to make the end product look a little more organic.
					
					Rather than doing the 'expected' act of just plopping in a obvious 'single' texture lookup, we're actually doing *two* of them, and taking the average of the two values.  The reason for this is a cheap attempt at making two textures instead of one (essentially just making two 'layers' of the same texture on the screen).  This is meant to make it look a little bit more organic - we might switch this around in the future, but that's all this is doing.
				*/
				
				vec4 fb_color = texture2D(u_anura_tex_map, texcoord);
				vec4 liquid_tex_color;
				
				if( water_type == 0 ){
					//Water texture & movement.
						liquid_tex_color = (
							  texture2D(u_water_texture, loc + vec2(0.2, u_anura_cycle*u_water_tex_speed[water_type]))
							+ texture2D(u_water_texture, loc + vec2(0.5, u_anura_cycle*u_water_tex_speed[water_type]))
						)/2;
						
				} else if ( water_type == 1 ) {
					//Acid texture and movement.
						liquid_tex_color = (
							  texture2D(u_acid_texture, loc + vec2(u_anura_cycle*u_water_tex_speed[water_type], 0.0))
							+ texture2D(u_acid_texture, loc + vec2(u_anura_cycle*u_water_tex_speed[water_type], 0.5))
						)/2;
						
				} else if ( water_type == 2 ) {
					//Deadly acid texture and movement.
						liquid_tex_color = (
							  texture2D(u_deadly_acid_texture, loc + vec2(0.2, u_anura_cycle*u_water_tex_speed[water_type] * +0.2))
							+ texture2D(u_deadly_acid_texture, loc + vec2(0.5, u_anura_cycle*u_water_tex_speed[water_type] * -1.5))
						)/2;
						
					//[ADDING_WATER] If adding a new water type, specify the new mix above.
					
				} else if ( water_type == 3 ) {
					//whitewater texture & movement.
//						liquid_tex_color = (
//							  texture2D(u_whitewater_texture, loc + vec2(u_anura_cycle *  2 * u_water_tex_speed[water_type], 0.0))
//							+ texture2D(u_whitewater_texture, loc + vec2(u_anura_cycle * -2 * u_water_tex_speed[water_type], 0.5 * sin(u_anura_cycle * 200)))
//						)/2;

						liquid_tex_color = (
							/*                            texture sample pos        ???                              ???              ???    ???                 ???                           ???               */
							+ texture2D(u_whitewater_texture, +loc/0.75 + vec2(u_anura_cycle * +2.0 * u_water_tex_speed[water_type], 0.00 + 0.006 * sin(u_anura_cycle / 3.0)  ))
							+ texture2D(u_whitewater_texture, -loc/1.00 + vec2(u_anura_cycle * +1.1 * u_water_tex_speed[water_type], 0.20 + 0.005 * sin(u_anura_cycle / 2.0) + 0.003 * sin(u_anura_cycle / 1.0)  ))
							+ texture2D(u_whitewater_texture, +loc/1.33 + vec2(u_anura_cycle * -1.1 * u_water_tex_speed[water_type], 0.50 + 0.004 * sin(u_anura_cycle / 2.5) + 0.004 * sin(u_anura_cycle / 1.5)  ))
							+ texture2D(u_whitewater_texture, -loc/1.66 + vec2(u_anura_cycle * -2.0 * u_water_tex_speed[water_type], 0.75 + 0.006 * sin(u_anura_cycle / 2.5)  ))
						)/4;
						
				} else {
					//No water found, just shade grey and abort *if* we get here.
					gl_FragColor = vec4(.3,.4,.5,1); //#4c667fff, make this findable by colour picker... hopefully.
					return;
				}
				
				
				/*
					This section does an implementation of a 'blend mode' for the whole chunk of water.
					
					We start by sampling the frame buffer (i.e. the screenshot of what's on the level already), and pluck the pixel we're looking at, and ask 'what is the brightness of the pixel' - we're asking for the overall brightness, so we don't care about the hue data, we just covert to grayscale. 
				*/

				//Populate array like this instead of using a literal because that's not supported on Macs.
				float blur_coefficients[33];

				blur_coefficients[0] =  0.000000000232830643653869;
				blur_coefficients[1] =  0.000000007450580596923828;
				blur_coefficients[2] =  0.00000011548399925231934;
				blur_coefficients[3] =  0.0000011548399925231934;
				blur_coefficients[4] =  0.000008372589945793152;
				blur_coefficients[5] =  0.00004688650369644165;
				blur_coefficients[6] =  0.00021098926663398743;
				blur_coefficients[7] =  0.000783674418926239;
				blur_coefficients[8] =  0.002448982559144497;
				blur_coefficients[9] =  0.0065306201577186584;
				blur_coefficients[10] = 0.015020426362752914;
				blur_coefficients[11] = 0.03004085272550583;
				blur_coefficients[12] = 0.0525714922696352;
				blur_coefficients[13] = 0.08087921887636185;
				blur_coefficients[14] = 0.10976465418934822;
				blur_coefficients[15] = 0.13171758502721786;
				blur_coefficients[16] = 0.13994993409141898;
				blur_coefficients[17] = 0.13171758502721786;
				blur_coefficients[18] = 0.10976465418934822;
				blur_coefficients[19] = 0.08087921887636185;
				blur_coefficients[20] = 0.0525714922696352;
				blur_coefficients[21] = 0.03004085272550583;
				blur_coefficients[22] = 0.015020426362752914;
				blur_coefficients[23] = 0.0065306201577186584;
				blur_coefficients[24] = 0.002448982559144497;
				blur_coefficients[25] = 0.000783674418926239;
				blur_coefficients[26] = 0.00021098926663398743;
				blur_coefficients[27] = 0.00004688650369644165;
				blur_coefficients[28] = 0.000008372589945793152;
				blur_coefficients[29] = 0.0000011548399925231934;
				blur_coefficients[30] = 0.00000011548399925231934;
				blur_coefficients[31] = 0.000000007450580596923828;
				blur_coefficients[32] = 0.000000000232830643653869;			



	
				float blur_accumulator_h = 0.;
				for(int i = 0; i != 33; ++i) {
					vec4 color = texture2D(u_anura_tex_map, texcoord + vec2( float(1 * (i - 6)) / u_anura_draw_area[2], 0.0));

					if(color.rgb == vec3(0)){
						blur_accumulator_h += blur_coefficients[i];
					}
					
				}

				float blur_accumulator_v = 0.;
				for(int i = 0; i != 33; ++i) {
					vec4 color = texture2D(u_anura_tex_map, texcoord + vec2(0.0, float(1 * (i - 6)) / u_anura_draw_area[3]));

					if(color.rgb == vec3(0)){
						blur_accumulator_v += blur_coefficients[i];
					}
					
				}
				
				float blur_accumulator = 1.0 - mix(blur_accumulator_h, blur_accumulator_v, 0.5);

				vec4 blurred_liquid = vec4(liquid_tex_color.rgb, blur_accumulator);

				vec3 screen_blended_color = blendScreen(
					fb_color.rgb,
					blurred_liquid.rgb,
					blurred_liquid.a
				);

				vec3 overlay_blended_color = blendOverlay(
					fb_color.rgb,
					blurred_liquid.rgb,
					blurred_liquid.a
				);
				
				
				/*
					[ADDING_WATER] Instead of having a hard-coded value for this; it picks from an array, using 'which kind of water' we are as the index.  If you're adding a new water type, you'll need to add another entry (it won't error out if you don't, but it'll treat the value as either zero, or we might be hitting 'out of array bounds' c-style Undefined Behavior, which is bad).
				
					Right above here, we run a full calc of what the pixel would look like if we blend it against what's already on screen; using either the photoshop-named 'screen' blending mode, or the 'overlay' blending mode.  Here, we decide how much of each we want to go into the final pixel by tweening between the two values. 
				*/
				vec3 semifinal_color = mix(screen_blended_color, overlay_blended_color, 
					float[](0.9, 0.65, 0.75, 0.55)[water_type]);

				vec4 final_color = vec4(semifinal_color, blurred_liquid.a);


				/*
					[ADDING_WATER] Same routine as above.
				
					This one is just a plain-and-simple 'opacity slider' for the entire shader effect.  How much of the final pixel is just what was already on-screen, versus how much is based on our shader stuff.
				*/
				
				gl_FragColor = mix(final_color, fb_color, 
					float[](0.2, 0.0, 0.0, 0.0)[water_type]);
				gl_FragColor.a = 1.0;
			}
		",
		
		create: "[//Load constant texture information into the shader, for all waters in the level.
			set(textures, liquid_textures),
			
			bind_texture(liquid_textures[0], 2),
			bind_texture(liquid_textures[1], 3),
			bind_texture(liquid_textures[2], 4),
			bind_texture(liquid_textures[3], 5),
			set(uniform_commands.u_water_texture, 2),
			set(uniform_commands.u_acid_texture, 3),
			set(uniform_commands.u_deadly_acid_texture, 4),
			set(uniform_commands.u_whitewater_texture, 5),
			
			
			//[ADDING_WATER] If adding a water type, add a new texture binding above. This is because we can't pass in uniform arrays from Anura.
			
			set(uniform_commands.u_water_tex_dim,   [if(ctrl, ctrl.texture_dim,   1) | ctrl <- ctrls]),
			set(uniform_commands.u_water_tex_speed, [if(ctrl, ctrl.texture_speed, 1) | ctrl <- ctrls]),
		] where liquid_textures = [
			if(ctrl, ctrl.get_texture, load_texture('default-animation.png'))
			| ctrl <- ctrls
		] where ctrls = [
			find(level.chars, value is obj water_controller or value is obj water_controller_rising or value is obj water_controller_ocean),
			find(level.chars, value is obj acid_controller),
			find(level.chars, value is obj acid_deadly_controller),
			find(level.chars, value is obj whitewater_controller),
			//[ADDING_WATER] The index of the water found in the list must be the water type number. All liquids must be in this list.
		]",

		draw: "[//Load dynamic level information into the shader.
			//Level information.
			set(uniform_commands.u_camera_pos, pos),
			set(uniform_commands.u_zoom, zoom),
			
			//Water rect information.
			set(uniform_commands.u_water_count, size(waters)),
			set(uniform_commands.u_water_area, fold(water_rects, a+b, [])),
			set(uniform_commands.u_water_type, (water_types+[-1]*8)[:8]), //This array amongst all others can't be half-populated, it needs all elements.
		]
		asserting not -1 in water_types | 'Unknown liquid found to shade, please add it below. (In [${map(waters, value.type)}])'
		where 
			water_rects = [[
				//Since we get water rects in level coordinates, and we want to transform them into zoomed screen coordinates for our shader (because the shader is processed at the wrong step of the pipeline in level.cpp - it's only done *after* zoom is applied) we must take the following steps:
				//1. Find the offset of the water bounds from the current visual center.
				//vvvvvvvvvvvvvvv vvvvvvvvvvvvvvvvvvvvvv
				//2. Scale those x-bounds from the visual center by level.zoom.
				//                                       vvvvvvv
				//3. Convert from current visual center to screen-space coordinates.
				//                                               vvvvvvvvvv
				((water._x_bound  - (pos[0] + win[0]/2)) * zoom) + win[0]/2,
				((water._y_bound  - (pos[1] + win[1]/2)) * zoom) + win[1]/2,
				((water._x2_bound - (pos[0] + win[0]/2)) * zoom) + win[0]/2,
				((water._y2_bound - (pos[1] + win[1]/2)) * zoom) + win[1]/2 
			] | water <- waters],
			water_types = [switch(true,
				water is obj water_controller,        0,
				water is obj water_controller_rising, 0,
				water is obj water_controller_ocean,  0,
				water is obj acid_controller,         1,
				water is obj acid_deadly_controller,  2,
				water is obj whitewater_controller,   3,
				//[ADDING_WATER] If your new water is shaded like an existing water, add it above and use an existing water type number. Otherwise, add a new water type number.
				-1
			) | water <- waters]
		where waters = (
			[water
				| water <- level.chars,
				  water is obj liquid,
				  rects_intersect(camera_rect, [water._x_bound, water._y_bound, water._x2_bound, water._y2_bound])
			] where camera_rect = [pos[0]-scale_margin[0], pos[1]-scale_margin[1], pos[0]+win[0]+scale_margin[0], pos[1]+win[1]+scale_margin[1]]
			  where scale_margin = [(pos[2]-win[0])/2, (pos[3]-win[1])/2]
			  //ðŸ ™ To find the camera_rect, _adjusting for zoom,_ we take the unscaled camera rect and add the difference between the unscaled and scaled camera size.
			  //  The alternative to this would be to calculate the distances from the center of the camera based on the current camera size.
		)[:8]
		where pos = level.camera_position,
		      win = level.window_size,
		      zoom = level.zoom_current"
	},

	{
		name: "liquid_LOW_END_SYSTEM",
		new: true,
		vertex: "
			uniform mat4 u_anura_mvp_matrix;
			//uniform float u_anura_cycle;
			//uniform vec4 u_anura_sprite_area;
			//uniform vec4 u_anura_draw_area;
			attribute vec2 a_anura_vertex;
			attribute vec2 a_anura_texcoord;
			varying vec2 v_texcoord;
			varying vec2 v_vertex;
			void main()
			{
				v_vertex = a_anura_vertex;
				gl_Position = u_anura_mvp_matrix * vec4(a_anura_vertex, 0.0, 1.0);
				v_texcoord = a_anura_texcoord;
			}
		",
		fragment: "
			#version 120
			uniform sampler2D u_anura_tex_map;
			//[ADDING_WATER] If adding a new water type, add its texture sampler.
			uniform float u_water_tex_dim[4];
			uniform float u_water_tex_speed[4];
			//[ADDING_WATER] If adding a new water type, increase the size of dim and speed by 1 each to accommodate the new data.
			uniform vec4 u_camera_pos;
			uniform float u_zoom;
			//uniform float u_intensity;
			uniform int u_water_count; //Can't be uint, that just... doesn't work. O_o
			uniform vec4 u_water_area[8]; //8 water areas on screen at one time max.
			uniform int u_water_type[8];  //The numeric water types of each area, so we know how to shade them. 1=water, 2=acid, etc.
			uniform float u_anura_cycle;
			uniform vec4 u_anura_draw_area;
			//uniform vec4 u_anura_sprite_area;
			varying vec2 v_texcoord;
			varying vec2 v_vertex;
			


			
			float ease_out_circ(float t)
			{
				return sqrt(1.0 - pow( (t-1.0), 2.0 ) );
			}

			float ease_in_circ(float t)
			{
				return 1.0 - sqrt(1.0 - pow(t, 2.0) );
			}

			float ease_in_out_circ(float t)
			{
				float time = t*2.0;

				if(time < 1.0){ 
					return ( 1.0 - sqrt(1.0 - pow(t,2.0) ) )/2.0;
				} else {
					return sqrt(1.0 - pow( (t-1.0), 2.0 ) )/2.0;
				}
			}

			float blendOverlay(float base, float blend) {
				return base<0.5?(2.0*base*blend):(1.0-2.0*(1.0-base)*(1.0-blend));
			}

			vec3 blendOverlay(vec3 base, vec3 blend) {
				return vec3(blendOverlay(base.r,blend.r),blendOverlay(base.g,blend.g),blendOverlay(base.b,blend.b));
			}

			vec3 blendOverlay(vec3 base, vec3 blend, float opacity) {
				return (blendOverlay(base, blend) * opacity + base * (1.0 - opacity));
			}			


			float blendScreen(float base, float blend) {
				return 1.0-((1.0-base)*(1.0-blend));
			}

			vec3 blendScreen(vec3 base, vec3 blend) {
				return vec3(blendScreen(base.r,blend.r),blendScreen(base.g,blend.g),blendScreen(base.b,blend.b));
			}

			vec3 blendScreen(vec3 base, vec3 blend, float opacity) {
				return (blendScreen(base, blend) * opacity + base * (1.0 - opacity));
			}
		
			void main()
			{
				vec2 texcoord = v_texcoord;
				
				/*
					This steps over multiple water areas - it artificially limits itself to the first 8 water areas that are onscreen (this gets done not here, in the `fragment` call, but down in the `draw` call below).
					
					The final return value is a single pixel's color.
					
					Since of course this is a shader, the end result we're going for is just one single pixel's color, so any 'scanning over multiple pixels' is just to get ingredients, not to output more than one. 
				*/
				
				//Find the index of the water rect whose pixel we're
				//shading. Overlap winning is arbitrary but stable.
				int water_index;
				float left, top, right, bottom;
				for(water_index = 0; water_index < u_water_count; water_index++) {
					left = max(u_anura_draw_area[0], u_water_area[water_index][0]); //Clip the water area to the screen, so that it doesn't slide around near the edge and produce artefacts.
					top = max(u_anura_draw_area[1], u_water_area[water_index][1]);
					right = min(u_anura_draw_area[2], u_water_area[water_index][2]);
					bottom = min(u_anura_draw_area[3], u_water_area[water_index][3]);
					
					//bounds check
					if(
						   v_vertex.x > left 
						&& v_vertex.x < right 
						&& v_vertex.y > top 
						&& v_vertex.y < bottom
					) {
						break; //found water_index, stop looking
					}
				}
				
				//Don't do anything if we didn't find a water.
				if(water_index == u_water_count) {
					gl_FragColor = vec4(texture2D(u_anura_tex_map, texcoord).rgb, 1.0);
					return;
				}
				
				vec4 fb_color = texture2D(u_anura_tex_map, texcoord);
				vec4 liquid_tex_color;
				
				int water_type = u_water_type[water_index];
				if( water_type == 0 ){ //Water texture
					liquid_tex_color = vec4(0.24, 0.84, 0.95, 1);
				} else if ( water_type == 1 ) { //Acid texture
					liquid_tex_color = vec4(0.4, 0.79, 0.02, 1);
				} else if ( water_type == 2 ) { //Deadly acid texture
					liquid_tex_color = vec4(0.91, 0.13, 0.33, 1);
				} else if ( water_type == 3 ) { //whitewater texture & movement.
					liquid_tex_color = vec4(0.44, 0.94, 0.97, 1);
				} else {
					//[ADDING_WATER] If adding a new water type, specify the new mix above.
					//No water found, just shade grey and abort *if* we get here.
					gl_FragColor = vec4(.3,.4,.5,1); //#4c667fff, make this findable by colour picker... hopefully.
					return;
				}
				
				
				/*
					This section does an implementation of a 'blend mode' for the whole chunk of water.
					
					We start by sampling the frame buffer (i.e. the screenshot of what's on the level already), and pluck the pixel we're looking at, and ask 'what is the brightness of the pixel' - we're asking for the overall brightness, so we don't care about the hue data, we just covert to grayscale. 
				*/

				//Populate array like this instead of using a literal because that's not supported on Macs.
				float blur_coefficients[33];

				blur_coefficients[0]  = 0.000000000232830643653869;
				blur_coefficients[1]  = 0.000000007450580596923828;
				blur_coefficients[2]  = 0.00000011548399925231934;
				blur_coefficients[3]  = 0.0000011548399925231934;
				blur_coefficients[4]  = 0.000008372589945793152;
				blur_coefficients[5]  = 0.00004688650369644165;
				blur_coefficients[6]  = 0.00021098926663398743;
				blur_coefficients[7]  = 0.000783674418926239;
				blur_coefficients[8]  = 0.002448982559144497;
				blur_coefficients[9]  = 0.0065306201577186584;
				blur_coefficients[10] = 0.015020426362752914;
				blur_coefficients[11] = 0.03004085272550583;
				blur_coefficients[12] = 0.0525714922696352;
				blur_coefficients[13] = 0.08087921887636185;
				blur_coefficients[14] = 0.10976465418934822;
				blur_coefficients[15] = 0.13171758502721786;
				blur_coefficients[16] = 0.13994993409141898;
				blur_coefficients[17] = 0.13171758502721786;
				blur_coefficients[18] = 0.10976465418934822;
				blur_coefficients[19] = 0.08087921887636185;
				blur_coefficients[20] = 0.0525714922696352;
				blur_coefficients[21] = 0.03004085272550583;
				blur_coefficients[22] = 0.015020426362752914;
				blur_coefficients[23] = 0.0065306201577186584;
				blur_coefficients[24] = 0.002448982559144497;
				blur_coefficients[25] = 0.000783674418926239;
				blur_coefficients[26] = 0.00021098926663398743;
				blur_coefficients[27] = 0.00004688650369644165;
				blur_coefficients[28] = 0.000008372589945793152;
				blur_coefficients[29] = 0.0000011548399925231934;
				blur_coefficients[30] = 0.00000011548399925231934;
				blur_coefficients[31] = 0.000000007450580596923828;
				blur_coefficients[32] = 0.000000000232830643653869;			



	
				float blur_accumulator_h = 0.;
				for(int i = 0; i < 33; i+=2) {
					vec4 color = texture2D(u_anura_tex_map, texcoord + vec2( float(1 * (i - 6)) / u_anura_draw_area[2], 0.0));

					if(color.rgb == vec3(0)){
						blur_accumulator_h += blur_coefficients[i]*2;
					}
					
				}

				float blur_accumulator_v = 0.;
				for(int i = 0; i < 33; i+=2) {
					vec4 color = texture2D(u_anura_tex_map, texcoord + vec2(0.0, float(1 * (i - 6)) / u_anura_draw_area[3]));

					if(color.rgb == vec3(0)){
						blur_accumulator_v += blur_coefficients[i]*2;
					}
					
				}
				
				float blur_accumulator = 1.0 - mix(blur_accumulator_h, blur_accumulator_v, 0.5);

				vec4 blurred_liquid = vec4(liquid_tex_color.rgb, blur_accumulator);

				vec3 screen_blended_color = blendScreen(
					fb_color.rgb,
					blurred_liquid.rgb,
					blurred_liquid.a
				);

				vec3 overlay_blended_color = blendOverlay(
					fb_color.rgb,
					blurred_liquid.rgb,
					blurred_liquid.a
				);
				
				
				/*
					[ADDING_WATER] Instead of having a hard-coded value for this; it picks from an array, using 'which kind of water' we are as the index.  If you're adding a new water type, you'll need to add another entry (it won't error out if you don't, but it'll treat the value as either zero, or we might be hitting 'out of array bounds' c-style Undefined Behavior, which is bad).
				
					Right above here, we run a full calc of what the pixel would look like if we blend it against what's already on screen; using either the photoshop-named 'screen' blending mode, or the 'overlay' blending mode.  Here, we decide how much of each we want to go into the final pixel by tweening between the two values. 
				*/
				vec3 semifinal_color = mix(screen_blended_color, overlay_blended_color, 
					float[](0.9, 0.65, 0.75, 0.55)[water_type]);

				vec4 final_color = vec4(semifinal_color, blurred_liquid.a);


				/*
					[ADDING_WATER] Same routine as above.
				
					This one is just a plain-and-simple 'opacity slider' for the entire shader effect.  How much of the final pixel is just what was already on-screen, versus how much is based on our shader stuff.
				*/
				
				gl_FragColor = mix(final_color, fb_color, 
					float[](0.9, 0.9, 0.9, 0.9)[water_type]);
				gl_FragColor.a = 1.0;
			}
		",
		
		create: "[//Load constant texture information into the shader, for all waters in the level.
			set(uniform_commands.u_water_tex_dim,   [if(ctrl, ctrl.texture_dim,   1) | ctrl <- ctrls]),
			set(uniform_commands.u_water_tex_speed, [if(ctrl, ctrl.texture_speed, 1) | ctrl <- ctrls]),
		] where ctrls = [
			find(level.chars, value is obj water_controller or value is obj water_controller_rising or value is obj water_controller_ocean),
			find(level.chars, value is obj acid_controller),
			find(level.chars, value is obj acid_deadly_controller),
			find(level.chars, value is obj whitewater_controller),
			//[ADDING_WATER] The index of the water found in the list must be the water type number. All liquids must be in this list.
		]",

		draw: "[//Load dynamic level information into the shader.
			//Level information.
			set(uniform_commands.u_camera_pos, level.camera_position),
			set(uniform_commands.u_zoom, level.zoom),
			
			//Water rect information.
			set(uniform_commands.u_water_count, size(waters)),
			set(uniform_commands.u_water_area, fold(water_rects, a+b, [])),
			set(uniform_commands.u_water_type, (water_types+[-1]*8)[:8]), //This array amongst all others can't be half-populated, it needs all elements.
		]
		asserting not -1 in water_types | 'Unknown liquid found to shade, please add it below. (In [${map(waters, value.type)}])'
		where 
			water_rects = [[
				water._x_bound  - pos[0],
				water._y_bound  - pos[1], 
				water._x2_bound - pos[0], 
				water._y2_bound - pos[1]
			] | water <- waters],
			water_types = [switch(true,
				water is obj water_controller,        0,
				water is obj water_controller_rising, 0,
				water is obj water_controller_ocean,  0,
				water is obj acid_controller,         1,
				water is obj acid_deadly_controller,  2,
				water is obj whitewater_controller,   3,
				//[ADDING_WATER] If your new water is shaded like an existing water, add it above and use an existing water type number. Otherwise, add a new water type number.
				-1
			) | water <- waters]
		where waters = (
			[water
				| water <- level.chars,
				  water is obj liquid,
				  rects_intersect(camera_rect, [water._x_bound, water._y_bound, water._x2_bound, water._y2_bound])
			] where camera_rect = [pos[0], pos[1], pos[0]+pos[2], pos[1]+pos[3]]
		)[:8]
		where pos = level.camera_position"
	},



	{
		name: "wind_distort",
		new: true,
		vertex: "
			uniform mat4 u_anura_mvp_matrix;
			//uniform float u_anura_cycle;
			//uniform vec4 u_anura_sprite_area;
			//uniform vec4 u_anura_draw_area;
			attribute vec2 a_anura_vertex;
			attribute vec2 a_anura_texcoord;
			varying vec2 v_texcoord;
			varying vec2 v_vertex;
			void main()
			{
				v_vertex = a_anura_vertex;
				gl_Position = u_anura_mvp_matrix * vec4(a_anura_vertex, 0.0, 1.0);
				v_texcoord = a_anura_texcoord;
			}
		",
		fragment: "
			uniform sampler2D u_anura_tex_map;
			//uniform float u_intensity;
			uniform vec4 u_wind_area[2];
			uniform float u_wind_state;
			uniform float u_y1_positions[2];
			uniform float u_y2_positions[2];
			uniform float u_anura_cycle;
			uniform vec4 u_anura_draw_area;
			//uniform vec4 u_anura_sprite_area;
			varying vec2 v_texcoord;
			varying vec2 v_vertex;
			void main()
			{
				vec2 texcoord = v_texcoord;
				
				for(int n = 0; n != 2; ++n) {
					if(u_wind_area[n][0] >= u_wind_area[n][2]) {
						break;
					}

					float left = max(u_anura_draw_area[0], u_wind_area[n][0]);
					float top = max(u_anura_draw_area[1], u_wind_area[n][1]);
					float right = min(u_anura_draw_area[2], u_wind_area[n][2]);
					float bottom = min(u_anura_draw_area[3], u_wind_area[n][3]);
					if(v_vertex.x > left
					   && v_vertex.y > top
					   && v_vertex.x < right 
					   && v_vertex.y < bottom){

						float raw_ypos = (v_vertex.y - top)/(bottom - top);
						float normalized_ypos = u_y1_positions[n] + (u_y2_positions[n] - u_y1_positions[n])*raw_ypos;

						//TODO: we have the normalized_ypos which is in [0,1] and tells us how high within the wind
						//rectangle we are. Use this to calculate distortion which is by how much we will distort
						//pixels in the x-axis.
						float distortion =  sin(1.0 - normalized_ypos)*sin(u_anura_cycle*0.01)*0.05 +
											sin(1.0 - normalized_ypos)*(0.20 * u_wind_state);

						texcoord.x = texcoord.x + distortion;
					}
				}
				gl_FragColor = texture2D(u_anura_tex_map, texcoord);
			}
		",

		draw: "[if(wind_rects, set(uniform_commands.u_wind_area, fold(wind_rects[:2], a+b)),
							   set(uniform_commands.u_wind_area, [0,0,0,0])),
				set(uniform_commands.u_y1_positions, (y1_positions + [0,0])[:2]),
				set(uniform_commands.u_y2_positions, (y2_positions + [0,0])[:2]),
							   ]

		  where wind_rects = map(rect_info, value.area)
		  where y1_positions = map(rect_info, value.y1)
		  where y2_positions = map(rect_info, value.y2)
		  
		  where rect_info = (
		
		[ {
			area: [wind._x_bound - pos[0], wind._y_bound - pos[1], wind._x2_bound - pos[0], wind._y2_bound - pos[1]],
		    y1: max(0.0, decimal(camera_rect[1] - wind._y_bound)/(wind._y2_bound - wind._y_bound)),
		    y2: min(1.0, decimal(camera_rect[3] - wind._y_bound)/(wind._y2_bound - wind._y_bound)),
		  }

		  | wind <- level.chars,
			wind.type = 'wind_distortion_controller',
			rects_intersect([wind._x_bound, wind._y_bound, wind._x2_bound, wind._y2_bound], camera_rect)
		] where camera_rect = [pos[0], pos[1], pos[0]+pos[2], pos[1]+pos[3]]
		  where pos = level.camera_position
		)
		"
	}, 

	{
		name: "rain_distort",
		new: true,
		vertex: "
			//boiler plate vertex shader. Probably doesn't need modification. The fragment shader
			//is where the fun is.
			uniform mat4 u_anura_mvp_matrix;
			//uniform float u_anura_cycle;
			//uniform vec4 u_anura_sprite_area;
			//uniform vec4 u_anura_draw_area;
			attribute vec2 a_anura_vertex;
			attribute vec2 a_anura_texcoord;
			varying vec2 v_texcoord;
			varying vec2 v_vertex;
			void main()
			{
				v_vertex = a_anura_vertex;
				gl_Position = u_anura_mvp_matrix * vec4(a_anura_vertex, 0.0, 1.0);
				v_texcoord = a_anura_texcoord;
			}
		",
		fragment: "
			uniform sampler2D u_anura_tex_map;
			uniform sampler2D u_rain_tex;
			uniform float u_anura_cycle;
			uniform vec4 u_anura_draw_area;
			varying vec2 v_texcoord;
			varying vec2 v_vertex;

			void main()
			{
				//right now this just gets the color from the frame buffer, gets the color from our
				//noise texture and 50/50 mixes the two.
				vec2 texcoord = v_texcoord;
				
				vec2 canvas_size = vec2(u_anura_draw_area[2], u_anura_draw_area[3]);
				vec2 rain_texcoord = texcoord*(canvas_size/vec2(256.0, 64.0));
				float animation_frame = floor(mod(floor(u_anura_cycle/5.0), 4.0));
				rain_texcoord.x = fract(rain_texcoord.x)/2.0 + animation_frame/4.0;
				rain_texcoord.y += u_anura_cycle/10.0;
				vec4 rain_col = texture2D(u_rain_tex, rain_texcoord);

				float cycle = fract(u_anura_cycle*0.15);
				float raw_translation = (rain_col.r / -0.19 / canvas_size.y);
				float translation = raw_translation * cycle * 2.0;
				vec4 fb_color_untranslated = texture2D(u_anura_tex_map,texcoord);
				texcoord.y=clamp(texcoord.y-translation * cycle, 0.0, 0.9999);
				vec4 fb_color = texture2D(u_anura_tex_map,texcoord);
				
				float alpha_level = clamp((cycle - 0.5) * 2.0, 0.0, 1.0);       // Controls rain opacity falloff
				fb_color = mix(fb_color, fb_color_untranslated, alpha_level);
				
				if(raw_translation < 0.0) {
   			 		fb_color = mix(fb_color, vec4(0.9, 0.9, 1.2, 0.1), 0.040);
				}
	

				//run another set of rain at a different phase.
				texcoord = v_texcoord;
				
				canvas_size = vec2(u_anura_draw_area[2], u_anura_draw_area[3]);
				rain_texcoord = texcoord*(canvas_size/vec2(256.0, 64.0));
				animation_frame = floor(mod(floor(u_anura_cycle/6.2), 4.0));
				rain_texcoord.x = fract(rain_texcoord.x)/2.0 + animation_frame/4.0;
				rain_texcoord.y += u_anura_cycle/11.2;
				rain_col = texture2D(u_rain_tex, rain_texcoord);

				cycle = fract(u_anura_cycle*0.23);
				raw_translation = (rain_col.r / -0.19 / canvas_size.y);
				translation = raw_translation * cycle * 2.0;
				fb_color_untranslated = fb_color;
				texcoord.y=clamp(texcoord.y-translation * cycle, 0.0, 0.9999);
				if(raw_translation < 0.0) {
					fb_color = texture2D(u_anura_tex_map,texcoord);
				}
				
				alpha_level = clamp((cycle - 0.5) * 2.0, 0.0, 1.0);       // Controls rain opacity falloff
				fb_color = mix(fb_color, fb_color_untranslated, alpha_level);
				
				if(raw_translation < 0.0) {
   			 		fb_color = mix(fb_color, vec4(0.9, 0.9, 1.2, 0.1), 0.080);
				}

				gl_FragColor = fb_color;
			}
		",

		draw: "
		[
		//fish the texture we want out of our controller. In future there will be a much nicer and easier way to do this.
		bind_texture(ctrl.rain_texture, 2),
		set(uniform_commands.u_rain_tex, 2),
		set(textures, [ctrl.rain_texture]),
		]
		where ctrl = find_or_die(level.chars, value is obj rain_effect_controller)
		"
	},
	
	{
		name: "shadow",
		new: true,
		vertex: "
			//boiler plate vertex shader. Probably doesn't need modification.
			//The fragment shader is where the fun is.
			uniform mat4 u_anura_mvp_matrix;
			//uniform float u_anura_cycle;
			//uniform vec4 u_anura_sprite_area;
			//uniform vec4 u_anura_draw_area;
			attribute vec2 a_anura_vertex;
			attribute vec2 a_anura_texcoord;
			varying vec2 v_texcoord;
			varying vec2 v_vertex;
			void main()
			{
				v_vertex = a_anura_vertex;
				gl_Position = u_anura_mvp_matrix * vec4(a_anura_vertex, 0.0, 1.0);
				v_texcoord = a_anura_texcoord;
			}
		",
		
		
		fragment: "
			#version 120
			uniform sampler2D u_anura_tex_map;
			uniform float u_shadow_opacity;
			uniform float u_shadow_red;
			uniform float u_shadow_green;
			uniform float u_shadow_blue;
			varying vec2 v_texcoord;
			varying vec2 v_vertex;

			void main() {
				vec4 fb_color = texture2D(u_anura_tex_map,v_texcoord); //Get a pixel of the active layer.
				gl_FragColor = vec4(u_shadow_red, u_shadow_green, u_shadow_blue, (1-fb_color[0]) * u_shadow_opacity);
			}
		",
	},
	
	{
		name: "shadow2",
		new: true,
		vertex: "
			//boiler plate vertex shader. Probably doesn't need modification.
			//The fragment shader is where the fun is.
			uniform mat4 u_anura_mvp_matrix;
			//uniform float u_anura_cycle;
			//uniform vec4 u_anura_sprite_area;
			//uniform vec4 u_anura_draw_area;
			attribute vec2 a_anura_vertex;
			attribute vec2 a_anura_texcoord;
			varying vec2 v_texcoord;
			varying vec2 v_vertex;
			void main()
			{
				v_vertex = a_anura_vertex;
				gl_Position = u_anura_mvp_matrix * vec4(a_anura_vertex, 0.0, 1.0);
				v_texcoord = a_anura_texcoord;
			}
		",
		
		
		fragment: "
			#version 120
			uniform sampler2D u_anura_tex_map;
			uniform float u_shadow_opacity;
			uniform float u_shadow_red;
			uniform float u_shadow_green;
			uniform float u_shadow_blue;
			varying vec2 v_texcoord;
			varying vec2 v_vertex;

			void main() {
				vec4 fb_color = texture2D(u_anura_tex_map, v_texcoord); //Get a pixel of the active layer.
				gl_FragColor = mix(
					vec4(u_shadow_red,  u_shadow_green, u_shadow_blue, u_shadow_opacity),
					vec4(1-fb_color[0], 1-fb_color[1],  1-fb_color[2], 0), //Change blend mode to multiplicative and then remove the `1-`s.
					fb_color[3]
				);
			}
		",
	},

	{
		name: "identity_op",
		new: true,
		vertex: "
			uniform mat4 u_anura_mvp_matrix;
			attribute vec2 a_anura_vertex;
			attribute vec2 a_anura_texcoord;
			varying vec2 v_texcoord;
			varying vec2 v_vertex;
			void main()
			{
				v_vertex = a_anura_vertex;
				gl_Position = u_anura_mvp_matrix * vec4(a_anura_vertex, 0.0, 1.0);
				v_texcoord = a_anura_texcoord;
			}
		",
		fragment: "
			uniform sampler2D u_anura_tex_map;
			varying vec2 v_texcoord;
			varying vec2 v_vertex;
			
			void main()
			{
				vec4 liquid_tex_color = vec4(0.0,0.0,0.0,0.0);
				vec2 texcoord = v_texcoord;
				bool elide_pixel = true;

				vec4 fb_color = texture2D(u_anura_tex_map, texcoord);

				gl_FragColor = fb_color; 
			}
		",

		draw: ""
	},


	],
}
