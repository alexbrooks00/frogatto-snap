# This is the hittable script which Frogatto depends on. Code in this file
# is specific to Frogatto.

{
id: "hittable",
prototype: ["hittable_std"],

properties: {

#-------------------------- item drop logic --------------------------#
	_drop_item_list: "{string -> int} :: {'heart_object' : 10, 'mana_cube' : 7}",
	_drop_item_weights: "{string -> int} :: {'heart_object' : 30, 'mana_cube' : 70}",
	drop_item_validity: "{string -> bool} :: {'heart_object' : (not level.player.hitpoints = level.player.max_hitpoints),  'mana_cube' : true }",
	
#-------------------------- cosmetic functions --------------------------#
	play_grabbed_cosmetics: "commands :: [play_hurt_sounds('neutral',1)]",

		//these should be the material-interaction sounds of an object being damaged; wood crunching, flesh squishing, glass breaking, etc.  A certain material will make different noise depending on what hurts it, and that's what this handles - wood burning is a very different sound from wood being crushed.  By default we provide a set of sounds for fleshy objects.									
	play_hurt_sounds: "def(string damage_type, decimal damage_amount) -> commands [if(play_object_specific_hurt_sounds(damage_type, damage_amount) != null, play_object_specific_hurt_sounds(damage_type, damage_amount),
								if(damage_amount > 0,
									switch(damage_type,
										'bite', sound('hurt-bite.wav'),
										'stab', sound('hurt-stab'+1d2+'.wav'),
										'slash', sound('hurt-slash'+1d3+'.wav'),
										'organic-bludgeon', sound('hurt-organic-bludgeon.wav'),
										'neutral', null,
										'electricity', sound('hurt-electricity.wav', 0.5)
									),
									switch(me.taxonomy,
										'plant', sound('resist-plant.wav'),
										'neutral', null
									),
								)),
								if(should_play_pain_sfx,[play_object_specific_pain_vocalization(damage_type, damage_amount), set(_last_played_pain_sfx,level.cycle)])]
									where should_play_pain_sfx = (level.cycle >= (_last_played_pain_sfx + 28))",
	
		//generally speaking, these sounds should not differ between damage types.	If a creature yelps in pain, it should always sound the same.  We might want it to be a matter of magnitude, though.						
								
	
	death_effects: "def(string type) -> commands
			if(me.underwater, splash_effect(),

			(switch(type,
					'none', null,  //for creatures that specifically want to die without showing anything
					
					/*these are a set of effects based on the type of creature dying*/
					'bug', [vfx('die_cloud_puffy'), sound('death-crunch'+1d2+'.wav')],
					'mushroom', [vfx('die_cloud_evaporative'), sound('death-crunch'+1d2+'.wav')],
					'plant', [vfx('die_cloud_evaporative'), sound('Death-Plant-Short'+1d5+'.wav')],
					'animal', [vfx('die_cloud'), sound('death-crunch'+1d2+'.wav'), spawn_gibs('bone_straight',1d2), spawn_gibs('bone_skull',1)],
					'milgramen', if(victim_is_big,	repeat_fx('die_cloud',10,5,50,70, sound('Milgramen-Explode'+1d5+'.wav')),
					 								[vfx('die_cloud'), sound('Milgramen-Explode'+1d5+'.wav')]),
					 								

					/*a set of effects based on the damage source; elsewhere in hittable these actually overrule the creature-type*/
					'fire', if(victim_is_big,		[repeat_fx('die_cloud_fire',5,4,30,30,sound('death-acid'+1d5+'.wav'))],
													[vfx('die_cloud_fire'), sound('death-acid'+1d5+'.wav')]),
					'acid', if(victim_is_big,		[repeat_fx('die_cloud_acid_small',40,1,50,50,null), sound('death-acid-bubbly1.wav')],
													[repeat_fx('die_cloud_acid_small',10,6,30,30,null), sound('death-acid-bubbly1.wav')]),
					'energy', [repeat_fx('die_cloud_electric_medium',1d2+5,4,20,30, null),repeat_fx('electric_spark1',3+1d3,1,60,60,null), sound('death-acid'+1d5+'.wav')],

					
					/*generic recurring effects for miscellaneous things - often not actually enemies*/
					'small', repeat_fx('die_cloud_small',5,4,10,10, null),
					'medium', repeat_fx('die_cloud_medium',5,4,20,30, null),
					'large', repeat_fx('die_cloud',5,10,50,70, sound('splat.ogg')),
					
					/*special custom effects for bosses*/
					'mushroom-boss', repeat_fx('die_cloud_evaporative',40,10,70,120, sound('death-crunch'+1d2+'.wav')),
					'moth-boss', repeat_fx('die_cloud_puffy',40,5,70,120, sound('death-crunch'+1d2+'.wav')),
			)
			where repeat_fx = def(string obj_type, int count, int delay, int spread_x, int spread_y, commands do_sound) -> commands spawn('particle_system_holder', me.mid_x, me.mid_y, if(1d2=2,-1,1), 
				execute(child, map(range(count),schedule(value*delay, [child.set_time_to_live(count*(delay+1)), vfx_spread(obj_type,spread_x,spread_y), do_sound ]))))
			
			
			) where vfx = def(string obj_type) -> commands spawn(obj_type, me.mid_x, me.mid_y, if(1d2=2,-1,1)))
			where vfx_spread = def(string obj_type, int spread_x, int spread_y) -> commands spawn(obj_type, me.mid_x + 1d(spread_x) - 1d(spread_x), me.mid_y  + 1d(spread_y) - 1d(spread_y), if(1d2=2,-1,1))
			where victim_is_big = me.physical_size >= 48
			",
	
	spawn_gibs: "def(string variation_type, int count) -> commands map([0]*count, spawn('bouncing_debris_chunk',x+1d10, y+1d10, if(1d2=2,1,-1), [add(child.variations, [variation_type]),child.init_vel('burst')]))",

	splash_effect: "def() -> commands if(me.underwater and me.water_bounds,
					[if(abs(me.water_bounds[1] - me.midpoint_y) > 40,
						spawn('water_splash_underwater_big', me.mid_x, me.mid_y, if(1d2=2,me.facing,-me.facing)),
						spawn('water_splash', me.midpoint_x, me.water_bounds[1]+10, if(1d2=2,me.facing,-me.facing))),
					sound('water-enter.ogg'), ])",
					
#-------------------------- sfx for material-interactions --------------------------#
	tile_tags: "{string -> string} :: //Twist around the data structure, so that each tile mnemonic is the key to a list of keys to the lists it's in.
		fold(
			map(flatten(values(tags)), 'tla',
				{(tla): string <- find(keys(tags), 'key', tla in tags[key])} ),
			a+b)
		where tags = {
			'wood': 		['fbr','acn','act','ast','isb','fnt','int',],
			'foliage':		['ngs',],
			'dirt':			['nrk','frg',],
			'stone':		['crk','dbk','cbk',],
			'wood_solid':	['ins','tnk',],
			'metal':		['ppl','dsb',],
		}",
	tagged_sfx: "def(string action) -> [{keys : [string], sound : commands}] switch(action,
		'slide', [
			{keys: ['wood'],	   sound: sound('slide-wood'+1d13+'.wav')},
			{keys: ['foliage'],	sound: sound('slide-foliage'+1d10+'.wav')},
			{keys: ['dirt'],	   sound: sound('slide-dirt'+1d4+'.wav')},
			{keys: ['stone'],	  sound: sound('slide-stone'+1d10+'.wav')},
			{keys: ['wood_solid'], sound: sound('slide-wood-solid'+1d5+'.wav')},
			{keys: ['metal'],	  sound: sound('slide-metal'+1d9+'.wav')},
			{keys: ['padding'],	sound: sound('footstep-slide-padding'+1d4+'.wav')},
			{keys: ['plastic'], sound: sound('footstep-slide-watercooler'+1d6+'.wav')},
			{keys: ['default'], sound: sound('slide-dirt'+1d4+'.wav')},
			],
		'jump', [
			{keys: ['wood'],	   sound: sound('jump-wood'+1d10+'.wav',0.7)},
			{keys: ['foliage'],	sound: sound('jump-foliage'+1d8+'.wav')},
			{keys: ['padding'],	sound: sound('footstep-jump-padding'+1d7+'.wav')},
			{keys: ['plastic'], sound: sound('footstep-jump-watercooler'+1d6+'.wav')},
			{keys: ['dirt'],	   sound: sound('jump-dirt'+1d9+'.wav')},
			{keys: ['stone'],	  sound: sound('footstep-run-stone'+1d8+'.wav')},
			{keys: ['wood_solid'], sound: sound('jump-wood-solid'+1d3+'.wav',0.6)},
			{keys: ['metal'],	  sound: sound('footstep-run-metal'+1d5+'.wav',0.6)},
			{keys: ['default'],	sound: sound('JumpSoft.ogg')},
			],
		'footfall', [
			{keys: ['wood'],	   sound: sound('footstep-'+run+'wood'+if(running,1d10,1d7)+'.wav',if(running,0.7,1.0))},
			{keys: ['foliage'],	sound: sound('footstep-'+run+'foliage'+if(running,1d9,1d6)+'.wav')},
			{keys: ['plastic'], sound: sound('footstep-run-watercooler'+1d5+'.wav')},
			{keys: ['dirt'],	   sound: sound('footstep-'+run+'dirt'+if(running,1d9,1d10)+'.wav')},
			{keys: ['stone'],	  sound: sound('footstep-'+run+'stone'+if(running,1d8,1d10)+'.wav')},
			{keys: ['padding'],	sound: sound('footstep-'+run+'padding'+if(running,1d7,1d7)+'.wav')},
			{keys: ['wood_solid'], sound: sound('footstep-'+run+'wood-solid'+if(running,1d7,1d8)+'.wav',0.6)},
			{keys: ['metal'],	  sound: sound('footstep-'+run+'metal'+if(running,1d5,1d5)+'.wav',0.8)},
			{keys: ['default'],	sound: sound('footstep'+1d4+'.wav')},
			] where run = if(animation in ['run'],'run-','') where running = (animation in ['run']) 
		)",


	choose_sfx: "def(string action) -> commands
		if(snd, snd.sound) where snd =  {keys: [string], sound: commands} <- find(sfx, 'effect', find(tags + ['default'], 'tag', tag in effect.keys)) where sfx = tagged_sfx(action), tags = tags_on",
		
		
			
	impact_cloud_silent: "def(int new_x, int new_y, string size) -> commands if(size = 'small', spawn('impact_cloud_small',new_x,new_y,1), spawn('impact_cloud',new_x,new_y,1))",
	impact_cloud: "def(int new_x, int new_y, string size) -> commands [impact_cloud_silent(new_x,new_y,size),play_impact_sound]",
	play_impact_sound: "commands :: switch(material_sound,
							'metal',	sound('collide-metal-heavy'+1d7+'.wav'),
							'coconut',	sound('hopper-block1.wav'),
							            sound('bump-2.wav'))",
	},

on_being_removed: "map(filter(spawned_children, value is obj shadow), remove_object(value))"
}
