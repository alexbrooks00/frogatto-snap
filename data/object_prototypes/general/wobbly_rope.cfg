{
	id: "wobbly_rope",
	prototype: ["standard_values"],
	
	properties: {
#-------------------------- boundary conditions --------------------------#
		bounds: {
			type: "{x: decimal, x2: decimal, y: decimal, y2: decimal}",
			init: "{x: mid_x, x2: mid_x+1, y: mid_y, y2: mid_y+1}"
		},
		_x_1: { type: "decimal", init: "mid_x" },
		_x_2: { type: "decimal", init: "mid_x+1" },
		_y_1: { type: "decimal", init: "mid_y" },
		_y_2: { type: "decimal", init: "mid_y+1" },

		length: "decimal :: lib.math.length(bounds.x, bounds.y, bounds.x2, bounds.y2)",
		set_ends: "def(decimal new_x1, decimal new_y1, decimal new_x2, decimal new_y2) -> commands [
			set(bounds, {
				x: new_x1,
				y: new_y1,
				x2: new_x2,
				y2: new_y2
			}),
			fire_event(me,'create'),
		]",

#-------------------------- distortion --------------------------#
		recombine_pairwise: "def([decimal|[decimal,decimal]] list) -> [[decimal, [decimal,decimal]]]
											([[decimal, [decimal,decimal]]] <- zip( ([decimal] <- list[0 : size(list)/2]), ([[decimal,decimal]] <- list[size(list)/2: size(list)]), [a,b]))",
		recombine_serially: "def([[decimal, [decimal,decimal]]] list) -> [decimal|[decimal,decimal]]
											map(list,value[0]) + map(list,value[1])",
		convert_to_unit_square_coords: "def([[decimal, [decimal,decimal]]] list) -> [[[decimal, decimal], [decimal,decimal]]]
															map(filter(list, value[0] >= 0.0 and value[0] < 1.0), [[((decimal <- value[0]) - 0.5)*2, -1.0] , ([decimal,decimal] <- value[1]) ]) +
															map(filter(list, value[0] >= 1.0 and value[0] < 2.0), [[1.0,  ((decimal <- value[0]) - 1.5)*2] , ([decimal,decimal] <- value[1]) ]) +
															map(filter(list, value[0] >= 2.0 and value[0] < 3.0), [[-((decimal <- value[0]) - 2.5)*2, 1.0 ] , ([decimal,decimal] <- value[1]) ]) +
															map(filter(list, value[0] >= 3.0 and value[0]<= 4.0), [[-1.0, -((decimal <- value[0]) - 3.5)*2] , ([decimal,decimal] <- value[1]) ])",
		flip_if_facing_left_or_upside_down: "def([[[decimal, decimal], [decimal,decimal]]] list) -> [[[decimal, decimal], [decimal,decimal]]]
													map(list, [[value[0][0] * facing,value[0][1] * v_flip] ,value[1]]) where v_flip = -upside_down",
		convert_back_to_serial_coords: "def([[[decimal,decimal], [decimal,decimal]]] list) -> [[decimal, [decimal,decimal]]]
													map(filter(list, value[0][1] = -1.0 and value [0][0] <  1.0), [( value[0][0]/2 + 0.5),value[1]]) + 
													map(filter(list, value[0][0] =  1.0 and value [0][1] <  1.0), [( value[0][1]/2 + 1.5),value[1]]) +
													map(filter(list, value[0][1] =  1.0 and value [0][0] > -1.0), [(-value[0][0]/2 + 2.5),value[1]]) +
													map(filter(list, value[0][0] = -1.0 and value [0][1] > -1.0), [(-value[0][1]/2 + 3.5),value[1]])",
		sort_back_to_serial_order: "def([[decimal, [decimal,decimal]]] list) -> [[decimal, [decimal,decimal]]]
											sort(list, a[0] < b[0])",
		
		converted_custom_draw_params: "[decimal|[decimal,decimal]] ::
							recombine_serially( sort_back_to_serial_order( convert_back_to_serial_coords( flip_if_facing_left_or_upside_down( convert_to_unit_square_coords( recombine_pairwise( custom_draw_params))))))",

		custom_draw_params: "[decimal|[decimal,decimal]] ::
			(([0.0, 0.25, 0.5, 0.75, 1.0,
			2.0, 2.25, 2.5, 2.75, 3.0,
			c_upper_edge, map(c_upper_edge, value * 0.60), map(c_upper_edge, value * 0.3), map(c_upper_edge, value * 0.05),still, 
			still, map(c_lower_edge, value * 0.05), map(c_lower_edge, value * 0.3), map(c_lower_edge, value * 0.60), c_lower_edge
			]) where still = [0,0]
				where c_upper_edge = [upper_edge[0]*facing, upper_edge[1]]
				where c_lower_edge = [lower_edge[0]*facing, lower_edge[1]]
				where upper_edge = zip( [x2,mid_y],newPos, a-b)
				where lower_edge = zip( [x2,mid_y],newPos, a-b))
				where newPos = [x,y + _magnitude]", //(orbit(x,mid_y, sin(15*cycle)*_magnitude, img_w))",

		_magnitude: "decimal :: 50.0",

	},
	
	on_process: "[
		set(mid_x, int( (bounds.x2 + bounds.x) / 2) ),
		set(y, int((bounds.y2 + bounds.y) / 2 - (length/2))),
		//set(draw_area, [0, 0, img_w/2, length/2]),
		set(rotate, ( angle(bounds.x, bounds.y, bounds.x2, bounds.y2) - 90) ),

		set(custom_draw, converted_custom_draw_params),
	]",

		
	animation: {
		id: "default",
		image: "characters/frogatto-tongueB.png",
		rect: [0,0,7,7],
		frames: 1,
		no_remove_alpha_borders: true,
	},
}